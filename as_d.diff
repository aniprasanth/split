+import 'package:flutter/material.dart';
+import 'package:flutter_test/flutter_test.dart';
+import 'package:mockito/mockito.dart';
+import 'package:mockito/annotations.dart';
+import 'package:provider/provider.dart';
+import 'package:splitzy/main.dart';
+import 'package:splitzy/screens/login_screen.dart';
+import 'package:splitzy/screens/home_screen.dart';
+import 'package:splitzy/screens/groups_screen.dart';
+import 'package:splitzy/screens/add_group_screen.dart';
+import 'package:splitzy/screens/group_detail_screen.dart';
+import 'package:splitzy/screens/add_expense_screen.dart';
+import 'package:splitzy/screens/edit_expense_screen.dart';
+import 'package:splitzy/screens/settle_up_screen.dart';
+import 'package:splitzy/screens/history_screen.dart';
+import 'package:splitzy/screens/my_expenses_screen.dart';
+import 'package:splitzy/screens/non_group_expenses_screen.dart';
+import 'package:splitzy/screens/settings_screen.dart';
+import 'package:splitzy/services/auth_service.dart';
+import 'package:splitzy/services/database_service.dart';
+import 'package:splitzy/services/contacts_service.dart';
+import 'package:splitzy/services/local_storage_service.dart';
+import 'package:splitzy/models/expense_model.dart';
+import 'package:splitzy/models/group_model.dart';
+import 'package:splitzy/models/settlement_model.dart';
+import 'package:splitzy/models/user_model.dart';
+import 'package:splitzy/utils/split_utils.dart';
+import 'package:splitzy/utils/validators.dart';
+
+import 'end_to_end_test_suite.mocks.dart';
+
+@GenerateMocks([
+  AuthService,
+  DatabaseService,
+  ContactsService,
+  LocalStorageService,
+])
+
+// Mock Contact class for testing
+class MockContact {
+  final String displayName;
+  final List<String> phones;
+
+  MockContact({required this.displayName, required this.phones});
+}
+
+void main() {
+  group('End-to-End Testing Suite', () {
+    late MockAuthService mockAuthService;
+    late MockDatabaseService mockDatabaseService;
+    late MockContactsService mockContactsService;
+    late MockLocalStorageService mockLocalStorageService;
+
+    setUp(() {
+      mockAuthService = MockAuthService();
+      mockDatabaseService = MockDatabaseService();
+      mockContactsService = MockContactsService();
+      mockLocalStorageService = MockLocalStorageService();
+
+      // Setup default mock behaviors
+      setupDefaultMocks();
+    });
+
+    void setupDefaultMocks() {
+      // Auth Service defaults
+      when(mockAuthService.currentUser).thenReturn(
+        SplitzyUser(
+          uid: 'test-user-id',
+          email: 'test@example.com',
+          name: 'Test User', // Changed from displayName to name
+        ),
+      );
+      when(mockAuthService.isLoading).thenReturn(false);
+      when(mockAuthService.isSigningIn).thenReturn(false);
+      when(mockAuthService.errorMessage).thenReturn(null);
+      when(mockAuthService.signInWithGoogle()).thenAnswer((_) async => 'success');
+      when(mockAuthService.clearError()).thenReturn(null);
+      when(mockAuthService.signOut()).thenAnswer((_) async => true);
+
+      // Database Service defaults
+      when(mockDatabaseService.isLoading).thenReturn(false);
+      when(mockDatabaseService.errorMessage).thenReturn(null);
+      when(mockDatabaseService.addExpense(any)).thenAnswer((_) async => true);
+      when(mockDatabaseService.createGroup(any)).thenAnswer((_) async => true);
+      when(mockDatabaseService.updateGroup(any)).thenAnswer((_) async => true);
+      when(mockDatabaseService.deleteGroup(any)).thenAnswer((_) async => true);
+      when(mockDatabaseService.deleteExpense(any, any)).thenAnswer((_) async => true);
+      when(mockDatabaseService.addSettlement(any)).thenAnswer((_) async => true);
+      when(mockDatabaseService.updateExpense(any)).thenAnswer((_) async => true);
+
+      // Contacts Service defaults
+      when(mockContactsService.hasPermission).thenReturn(true);
+      when(mockContactsService.isLoading).thenReturn(false);
+      when(mockContactsService.contacts).thenReturn([]);
+      when(mockContactsService.requestPermission()).thenAnswer((_) async => true);
+
+      // Local Storage Service defaults
+      when(mockLocalStorageService.upsertCachedExpense(any, any)).thenAnswer((_) async => true);
+    }
+
+    Widget createTestApp(Widget child) {
+      return MaterialApp(
+        home: MultiProvider(
+          providers: [
+            ChangeNotifierProvider<AuthService>.value(value: mockAuthService),
+            ChangeNotifierProvider<DatabaseService>.value(value: mockDatabaseService),
+            ChangeNotifierProvider<ContactsService>.value(value: mockContactsService),
+            Provider<LocalStorageService>.value(value: mockLocalStorageService),
+          ],
+          child: child,
+        ),
+      );
+    }
+
+    group('1. Authentication and Login Flow', () {
+      testWidgets('Complete login flow with Google Sign-In', (tester) async {
+        // Test unauthenticated state
+        when(mockAuthService.currentUser).thenReturn(null);
+
+        await tester.pumpWidget(createTestApp(const LoginScreen()));
+
+        // Verify login screen elements
+        expect(find.text('Splitzy'), findsOneWidget);
+        expect(find.text('Sign in with Google'), findsOneWidget);
+
+        // Test loading state
+        when(mockAuthService.isSigningIn).thenReturn(true);
+        await tester.pump();
+
+        expect(find.byType(CircularProgressIndicator), findsOneWidget);
+
+        // Test successful login
+        when(mockAuthService.currentUser).thenReturn(
+          SplitzyUser(uid: 'test-user-id', email: 'test@example.com', name: 'Test User'),
+        );
+        when(mockAuthService.isSigningIn).thenReturn(false);
+
+        await tester.pumpWidget(createTestApp(const HomeScreen()));
+
+        // Verify home screen elements
+        expect(find.text('Splitzy'), findsOneWidget);
+        expect(find.byType(BottomNavigationBar), findsOneWidget);
+      });
+
+      testWidgets('Login error handling', (tester) async {
+        when(mockAuthService.signInWithGoogle()).thenThrow(Exception('Network error'));
+        when(mockAuthService.errorMessage).thenReturn('Sign-in failed');
+
+        await tester.pumpWidget(createTestApp(const LoginScreen()));
+
+        // Tap sign in button
+        await tester.tap(find.text('Sign in with Google'));
+        await tester.pumpAndSettle();
+
+        // Verify error handling
+        expect(find.text('Sign-in failed'), findsOneWidget);
+      });
+
+      testWidgets('Multiple rapid login attempts prevention', (tester) async {
+        await tester.pumpWidget(createTestApp(const LoginScreen()));
+
+        // Rapid taps should be prevented
+        await tester.tap(find.text('Sign in with Google'));
+        await tester.tap(find.text('Sign in with Google'));
+        await tester.tap(find.text('Sign in with Google'));
+
+        // Verify only one call was made
+        verify(mockAuthService.signInWithGoogle()).called(1);
+      });
+    });
+
+    group('2. Navigation and Screen Flow', () {
+      testWidgets('Complete navigation flow through all screens', (tester) async {
+        await tester.pumpWidget(createTestApp(const HomeScreen()));
+
+        // Test bottom navigation
+        await tester.tap(find.byIcon(Icons.group));
+        await tester.pumpAndSettle();
+        expect(find.text('Groups'), findsOneWidget);
+
+        await tester.tap(find.byIcon(Icons.receipt));
+        await tester.pumpAndSettle();
+        expect(find.text('My Expenses'), findsOneWidget);
+
+        await tester.tap(find.byIcon(Icons.account_balance_wallet));
+        await tester.pumpAndSettle();
+        expect(find.text('Settle Up'), findsOneWidget);
+
+        await tester.tap(find.byIcon(Icons.history));
+        await tester.pumpAndSettle();
+        expect(find.text('Transaction History'), findsOneWidget);
+
+        await tester.tap(find.byIcon(Icons.settings));
+        await tester.pumpAndSettle();
+        expect(find.text('Settings'), findsOneWidget);
+      });
+
+      testWidgets('Back navigation and state preservation', (tester) async {
+        await tester.pumpWidget(createTestApp(const GroupsScreen()));
+
+        // Navigate to add group
+        await tester.tap(find.byIcon(Icons.add));
+        await tester.pumpAndSettle();
+
+        // Fill form partially
+        await tester.enterText(find.byType(TextFormField), 'Test Group');
+
+        // Navigate back
+        await tester.tap(find.byIcon(Icons.arrow_back));
+        await tester.pumpAndSettle();
+
+        // Verify back navigation worked
+        expect(find.text('Groups'), findsOneWidget);
+      });
+    });
+
+    group('3. Group Management - Complete Flow', () {
+      testWidgets('Create, edit, and delete group flow', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const GroupsScreen()));
+
+        // Create group
+        await tester.tap(find.byIcon(Icons.add));
+        await tester.pumpAndSettle();
+
+        await tester.enterText(find.byType(TextFormField), 'Test Group');
+        await tester.tap(find.text('Create'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.createGroup(any)).called(1);
+
+        // Mock group creation success
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([
+          GroupModel(
+            id: 'test-group-id',
+            name: 'Test Group',
+            members: ['test-user-id'],
+            memberNames: {'test-user-id': 'Test User'},
+            createdBy: 'test-user-id',
+            createdAt: DateTime.now(),
+          ),
+        ]));
+
+        await tester.pumpAndSettle();
+
+        // Edit group
+        await tester.tap(find.byIcon(Icons.more_vert));
+        await tester.pumpAndSettle();
+        await tester.tap(find.text('Edit'));
+        await tester.pumpAndSettle();
+
+        await tester.enterText(find.byType(TextFormField), 'Updated Group');
+        await tester.tap(find.text('Update'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.updateGroup(any)).called(1);
+
+        // Delete group
+        await tester.tap(find.byIcon(Icons.more_vert));
+        await tester.pumpAndSettle();
+        await tester.tap(find.text('Delete'));
+        await tester.pumpAndSettle();
+        await tester.tap(find.text('Delete'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.deleteGroup(any)).called(1);
+      });
+
+      testWidgets('Group validation and error handling', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const GroupsScreen()));
+
+        // Test empty group name
+        await tester.tap(find.byIcon(Icons.add));
+        await tester.pumpAndSettle();
+
+        await tester.tap(find.text('Create'));
+        await tester.pumpAndSettle();
+
+        // Should show validation error
+        expect(find.text('Please enter a group name'), findsOneWidget);
+
+        // Test network error
+        when(mockDatabaseService.createGroup(any))
+            .thenAnswer((_) async => false);
+        when(mockDatabaseService.errorMessage)
+            .thenReturn('Network error');
+
+        await tester.enterText(find.byType(TextFormField), 'Test Group');
+        await tester.tap(find.text('Create'));
+        await tester.pumpAndSettle();
+
+        expect(find.text('Network error'), findsOneWidget);
+      });
+    });
+
+    group('4. Expense Management - Complete Flow', () {
+      testWidgets('Group expense creation and management', (tester) async {
+        final testGroup = GroupModel(
+          id: 'test-group-id',
+          name: 'Test Group',
+          members: ['test-user-id', 'other-user-id'],
+          memberNames: {
+            'test-user-id': 'Test User',
+            'other-user-id': 'Other User',
+          },
+          createdBy: 'test-user-id',
+          createdAt: DateTime.now(),
+        );
+
+        await tester.pumpWidget(createTestApp(AddExpenseScreen(group: testGroup)));
+
+        // Fill expense form
+        await tester.enterText(find.byType(TextFormField).first, 'Test Expense');
+        await tester.enterText(find.byType(TextFormField).last, '100.00');
+
+        // Select payer and members
+        await tester.tap(find.text('Test User')); // Select payer
+        await tester.pumpAndSettle();
+
+        await tester.tap(find.text('Other User')); // Select member for split
+        await tester.pumpAndSettle();
+
+        // Save expense
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.addExpense(any)).called(1);
+      });
+
+      testWidgets('Non-group expense creation with member addition', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Verify Add Person button is visible
+        expect(find.text('Add Person'), findsOneWidget);
+
+        // Add member manually
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+
+        await tester.enterText(find.byType(TextField), 'John Doe');
+        await tester.testTextInput.receiveAction(TextInputAction.done);
+        await tester.pumpAndSettle();
+
+        // Verify member was added
+        expect(find.text('John Doe'), findsOneWidget);
+
+        // Fill expense details
+        await tester.enterText(find.byType(TextFormField).first, 'Non-Group Expense');
+        await tester.enterText(find.byType(TextFormField).last, '150.00');
+
+        // Save expense
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.addExpense(any)).called(1);
+      });
+
+      testWidgets('Contact integration for member addition', (tester) async {
+        when(mockContactsService.contacts).thenReturn([
+          MockContact(displayName: 'Jane Doe', phones: []),
+          MockContact(displayName: 'Bob Smith', phones: []),
+        ]);
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+
+        // Tap on contact
+        await tester.tap(find.text('Jane Doe'));
+        await tester.pumpAndSettle();
+
+        // Verify contact was added
+        expect(find.text('Jane Doe'), findsOneWidget);
+      });
+
+      testWidgets('Expense editing functionality', (tester) async {
+        final testExpense = ExpenseModel(
+          id: 'test-expense-id',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0,
+          description: 'Original Description',
+          split: {'test-user-id': 100.0},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        final testGroup = GroupModel(
+          id: 'test-group-id',
+          name: 'Test Group',
+          members: ['test-user-id'],
+          memberNames: {'test-user-id': 'Test User'},
+          createdBy: 'test-user-id',
+          createdAt: DateTime.now(),
+        );
+
+        await tester.pumpWidget(createTestApp(EditExpenseScreen(
+          expense: testExpense,
+          group: testGroup,
+        )));
+
+        // Edit expense
+        await tester.enterText(find.byType(TextFormField).first, 'Updated Description');
+        await tester.enterText(find.byType(TextFormField).last, '200.00');
+
+        await tester.tap(find.text('Save Changes'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.updateExpense(any)).called(1);
+      });
+
+      testWidgets('Expense deletion with confirmation', (tester) async {
+        final testExpense = ExpenseModel(
+          id: 'test-expense-id',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0,
+          description: 'Test Expense',
+          split: {'test-user-id': 100.0},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        final testGroup = GroupModel(
+          id: 'test-group-id',
+          name: 'Test Group',
+          members: ['test-user-id'],
+          memberNames: {'test-user-id': 'Test User'},
+          createdBy: 'test-user-id',
+          createdAt: DateTime.now(),
+        );
+
+        when(mockDatabaseService.getGroupExpenses(any))
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getSettlements(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(GroupDetailScreen(group: testGroup)));
+        await tester.pumpAndSettle();
+
+        // Delete expense
+        await tester.tap(find.byIcon(Icons.more_vert));
+        await tester.pumpAndSettle();
+        await tester.tap(find.text('Delete'));
+        await tester.pumpAndSettle();
+        await tester.tap(find.text('Delete'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.deleteExpense(any, any)).called(1);
+      });
+    });
+
+    group('5. Settle Up Screen - Real-time Updates', () {
+      testWidgets('Dynamic settlement display and marking as settled', (tester) async {
+        final testExpense = ExpenseModel(
+          id: 'test-expense-id',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0,
+          description: 'Test Expense',
+          split: {'test-user-id': 50.0, 'other-user-id': 50.0},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        when(mockDatabaseService.getAllExpenses())
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([
+          GroupModel(
+            id: 'test-group-id',
+            name: 'Test Group',
+            members: ['test-user-id', 'other-user-id'],
+            memberNames: {
+              'test-user-id': 'Test User',
+              'other-user-id': 'Other User',
+            },
+            createdBy: 'test-user-id',
+            createdAt: DateTime.now(),
+          ),
+        ]));
+        when(mockDatabaseService.getAllSettlementsForUser(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const SettleUpScreen()));
+        await tester.pumpAndSettle();
+
+        // Verify tabs show correct labels
+        expect(find.text('To Give'), findsOneWidget);
+        expect(find.text('To Get'), findsOneWidget);
+
+        // Verify unsettled amount is shown
+        expect(find.text('â‚¹50.00'), findsOneWidget);
+
+        // Mark as settled
+        await tester.tap(find.text('Mark as Settled'));
+        await tester.pumpAndSettle();
+        await tester.tap(find.text('Mark Settled'));
+        await tester.pumpAndSettle();
+
+        verify(mockDatabaseService.addSettlement(any)).called(1);
+      });
+
+      testWidgets('Settlement with completed transactions filtered out', (tester) async {
+        final testExpense = ExpenseModel(
+          id: 'test-expense-id',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0,
+          description: 'Test Expense',
+          split: {'test-user-id': 50.0, 'other-user-id': 50.0},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        final testSettlement = SettlementModel(
+          id: 'test-settlement-id',
+          fromUser: 'test-user-id',
+          fromUserName: 'Test User',
+          toUser: 'other-user-id',
+          toUserName: 'Other User',
+          amount: 25.0,
+          groupId: 'test-group-id',
+          groupName: 'Test Group',
+          paymentMethod: 'Manual',
+          status: SettlementStatus.completed,
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        when(mockDatabaseService.getAllExpenses())
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([
+          GroupModel(
+            id: 'test-group-id',
+            name: 'Test Group',
+            members: ['test-user-id', 'other-user-id'],
+            memberNames: {
+              'test-user-id': 'Test User',
+              'other-user-id': 'Other User',
+            },
+            createdBy: 'test-user-id',
+            createdAt: DateTime.now(),
+          ),
+        ]));
+        when(mockDatabaseService.getAllSettlementsForUser(any))
+            .thenAnswer((_) => Stream.value([testSettlement]));
+
+        await tester.pumpWidget(createTestApp(const SettleUpScreen()));
+        await tester.pumpAndSettle();
+
+        // Verify only remaining unsettled amount is shown (50 - 25 = 25)
+        expect(find.text('â‚¹25.00'), findsOneWidget);
+      });
+    });
+
+    group('6. Data Integrity and Consistency', () {
+      testWidgets('Data consistency across all screens', (tester) async {
+        final testExpense = ExpenseModel(
+          id: 'test-expense-id',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0,
+          description: 'Test Expense',
+          split: {'test-user-id': 50.0, 'other-user-id': 50.0},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        final testGroup = GroupModel(
+          id: 'test-group-id',
+          name: 'Test Group',
+          members: ['test-user-id', 'other-user-id'],
+          memberNames: {
+            'test-user-id': 'Test User',
+            'other-user-id': 'Other User',
+          },
+          createdBy: 'test-user-id',
+          createdAt: DateTime.now(),
+        );
+
+        // Mock data for all screens
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([testGroup]));
+        when(mockDatabaseService.getGroupExpenses(any))
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getAllExpenses())
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getMyExpenses(any))
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getNonGroupExpenses(any))
+            .thenAnswer((_) => Stream.value([]));
+        when(mockDatabaseService.getTransactionHistory(any))
+            .thenAnswer((_) => Stream.value([testExpense]));
+
+        // Test Groups Screen
+        await tester.pumpWidget(createTestApp(const GroupsScreen()));
+        await tester.pumpAndSettle();
+        expect(find.text('Test Group'), findsOneWidget);
+
+        // Test My Expenses Screen
+        await tester.pumpWidget(createTestApp(const MyExpensesScreen()));
+        await tester.pumpAndSettle();
+        expect(find.text('Test Expense'), findsOneWidget);
+
+        // Test History Screen
+        await tester.pumpWidget(createTestApp(const HistoryScreen()));
+        await tester.pumpAndSettle();
+        expect(find.text('Test Expense'), findsOneWidget);
+      });
+
+      testWidgets('Real-time data synchronization', (tester) async {
+        final testExpense = ExpenseModel(
+          id: 'test-expense-id',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0,
+          description: 'Test Expense',
+          split: {'test-user-id': 100.0},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        // Start with empty data
+        when(mockDatabaseService.getAllExpenses())
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const MyExpensesScreen()));
+        await tester.pumpAndSettle();
+
+        expect(find.text('No expenses found'), findsOneWidget);
+
+        // Update with new data
+        when(mockDatabaseService.getAllExpenses())
+            .thenAnswer((_) => Stream.value([testExpense]));
+
+        await tester.pumpAndSettle();
+
+        expect(find.text('Test Expense'), findsOneWidget);
+      });
+    });
+
+    group('7. Edge Cases and Error Handling', () {
+      testWidgets('Network error handling', (tester) async {
+        when(mockDatabaseService.addExpense(any))
+            .thenAnswer((_) async => false);
+        when(mockDatabaseService.errorMessage)
+            .thenReturn('Network error occurred');
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Fill form and try to save
+        await tester.enterText(find.byType(TextFormField).first, 'Test Expense');
+        await tester.enterText(find.byType(TextFormField).last, '100.00');
+
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+        await tester.enterText(find.byType(TextField), 'John Doe');
+        await tester.testTextInput.receiveAction(TextInputAction.done);
+        await tester.pumpAndSettle();
+
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        expect(find.text('Failed to add expense. Please try again.'), findsOneWidget);
+      });
+
+      testWidgets('Permission denied handling', (tester) async {
+        when(mockContactsService.hasPermission).thenReturn(false);
+        when(mockContactsService.requestPermission()).thenAnswer((_) async => false);
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+
+        await tester.tap(find.text('Grant contacts permission'));
+        await tester.pumpAndSettle();
+
+        expect(find.text('Permission denied'), findsOneWidget);
+      });
+
+      testWidgets('Large amount handling', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Test very large amount
+        await tester.enterText(find.byType(TextFormField).last, '999999.99');
+
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+        await tester.enterText(find.byType(TextField), 'John Doe');
+        await tester.testTextInput.receiveAction(TextInputAction.done);
+        await tester.pumpAndSettle();
+
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        // Should handle large amount without issues
+        verify(mockDatabaseService.addExpense(any)).called(1);
+      });
+
+      testWidgets('Special characters in input fields', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Test special characters
+        await tester.enterText(find.byType(TextFormField).first, 'Test Expense with Ã©mojis ðŸŽ‰ and symbols @#$%');
+        await tester.enterText(find.byType(TextFormField).last, '100.00');
+
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+        await tester.enterText(find.byType(TextField), 'JosÃ© MarÃ­a');
+        await tester.testTextInput.receiveAction(TextInputAction.done);
+        await tester.pumpAndSettle();
+
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        // Should handle special characters without issues
+        verify(mockDatabaseService.addExpense(any)).called(1);
+      });
+
+      testWidgets('Empty and invalid input validation', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Try to save with empty fields
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        // Should show validation errors
+        expect(find.text('Please enter a description'), findsOneWidget);
+        expect(find.text('Please enter an amount'), findsOneWidget);
+
+        // Test invalid amount
+        await tester.enterText(find.byType(TextFormField).last, 'invalid');
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        expect(find.text('Please enter a valid amount'), findsOneWidget);
+      });
+    });
+
+    group('8. Performance and Responsiveness', () {
+      testWidgets('UI responsiveness under slow network', (tester) async {
+        // Simulate slow network
+        when(mockDatabaseService.addExpense(any))
+            .thenAnswer((_) async {
+          await Future.delayed(const Duration(seconds: 2));
+          return true;
+        });
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Fill form
+        await tester.enterText(find.byType(TextFormField).first, 'Test Expense');
+        await tester.enterText(find.byType(TextFormField).last, '100.00');
+
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+        await tester.enterText(find.byType(TextField), 'John Doe');
+        await tester.testTextInput.receiveAction(TextInputAction.done);
+        await tester.pumpAndSettle();
+
+        // Tap save and verify loading state
+        await tester.tap(find.text('Add Expense'));
+        await tester.pump();
+
+        // Should show loading state
+        expect(find.text('Adding...'), findsOneWidget);
+        expect(find.byType(CircularProgressIndicator), findsOneWidget);
+
+        // UI should remain responsive
+        expect(find.byType(Scaffold), findsOneWidget);
+      });
+
+      testWidgets('Multiple rapid interactions prevention', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Fill form
+        await tester.enterText(find.byType(TextFormField).first, 'Test Expense');
+        await tester.enterText(find.byType(TextFormField).last, '100.00');
+
+        await tester.tap(find.text('Add Person'));
+        await tester.pumpAndSettle();
+        await tester.enterText(find.byType(TextField), 'John Doe');
+        await tester.testTextInput.receiveAction(TextInputAction.done);
+        await tester.pumpAndSettle();
+
+        // Multiple rapid taps
+        await tester.tap(find.text('Add Expense'));
+        await tester.tap(find.text('Add Expense'));
+        await tester.tap(find.text('Add Expense'));
+
+        // Should only call once
+        verify(mockDatabaseService.addExpense(any)).called(1);
+      });
+
+      testWidgets('Large data set handling', (tester) async {
+        // Create large dataset
+        final largeExpenseList = List.generate(100, (index) => ExpenseModel(
+          id: 'test-expense-id-$index',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0 + index,
+          description: 'Test Expense $index',
+          split: {'test-user-id': 100.0 + index},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        ));
+
+        when(mockDatabaseService.getAllExpenses())
+            .thenAnswer((_) => Stream.value(largeExpenseList));
+
+        await tester.pumpWidget(createTestApp(const MyExpensesScreen()));
+        await tester.pumpAndSettle();
+
+        // Should handle large dataset without freezing
+        expect(find.byType(ListView), findsOneWidget);
+        expect(find.text('Test Expense 0'), findsOneWidget);
+        expect(find.text('Test Expense 99'), findsOneWidget);
+      });
+    });
+
+    group('9. Accessibility and UI Standards', () {
+      testWidgets('Semantic labels and accessibility', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Verify semantic labels
+        expect(find.bySemanticsLabel('Description'), findsOneWidget);
+        expect(find.bySemanticsLabel('Amount'), findsOneWidget);
+        expect(find.bySemanticsLabel('Add Person'), findsOneWidget);
+      });
+
+      testWidgets('Text formatting and consistency', (tester) async {
+        await tester.pumpWidget(createTestApp(const SettleUpScreen()));
+
+        // Verify consistent text formatting
+        expect(find.text('To Give'), findsOneWidget);
+        expect(find.text('To Get'), findsOneWidget);
+
+        // Verify currency formatting
+        expect(find.text('â‚¹'), findsOneWidget);
+      });
+
+      testWidgets('Button states and feedback', (tester) async {
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.pumpWidget(createTestApp(const AddExpenseScreen()));
+
+        // Verify button states
+        final addButton = find.text('Add Expense');
+        expect(addButton, findsOneWidget);
+
+        // Button should be enabled initially
+        expect(tester.widget<ElevatedButton>(addButton).onPressed, isNotNull);
+      });
+    });
+
+    group('10. Integration Tests', () {
+      testWidgets('Complete user journey from login to expense creation', (tester) async {
+        // Start with login
+        when(mockAuthService.currentUser).thenReturn(null);
+        await tester.pumpWidget(createTestApp(const LoginScreen()));
+
+        // Login
+        when(mockAuthService.currentUser).thenReturn(
+          SplitzyUser(uid: 'test-user-id', email: 'test@example.com', name: 'Test User'),
+        );
+        await tester.pumpWidget(createTestApp(const HomeScreen()));
+
+        // Create group
+        await tester.tap(find.byIcon(Icons.group));
+        await tester.pumpAndSettle();
+
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([]));
+
+        await tester.tap(find.byIcon(Icons.add));
+        await tester.pumpAndSettle();
+
+        await tester.enterText(find.byType(TextFormField), 'Test Group');
+        await tester.tap(find.text('Create'));
+        await tester.pumpAndSettle();
+
+        // Create expense
+        await tester.tap(find.byIcon(Icons.receipt));
+        await tester.pumpAndSettle();
+
+        await tester.tap(find.byIcon(Icons.add));
+        await tester.pumpAndSettle();
+
+        await tester.enterText(find.byType(TextFormField).first, 'Test Expense');
+        await tester.enterText(find.byType(TextFormField).last, '100.00');
+        await tester.tap(find.text('Add Expense'));
+        await tester.pumpAndSettle();
+
+        // Verify complete flow
+        verify(mockDatabaseService.createGroup(any)).called(1);
+        verify(mockDatabaseService.addExpense(any)).called(1);
+      });
+
+      testWidgets('Data consistency across complete workflow', (tester) async {
+        final testGroup = GroupModel(
+          id: 'test-group-id',
+          name: 'Test Group',
+          members: ['test-user-id'],
+          memberNames: {'test-user-id': 'Test User'},
+          createdBy: 'test-user-id',
+          createdAt: DateTime.now(),
+        );
+
+        final testExpense = ExpenseModel(
+          id: 'test-expense-id',
+          groupId: 'test-group-id',
+          payer: 'test-user-id',
+          payerName: 'Test User',
+          amount: 100.0,
+          description: 'Test Expense',
+          split: {'test-user-id': 100.0},
+          date: DateTime.now(),
+          createdAt: DateTime.now(),
+        );
+
+        // Mock data for all screens
+        when(mockDatabaseService.getUserGroups(any))
+            .thenAnswer((_) => Stream.value([testGroup]));
+        when(mockDatabaseService.getGroupExpenses(any))
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getAllExpenses())
+            .thenAnswer((_) => Stream.value([testExpense]));
+        when(mockDatabaseService.getMyExpenses(any))
+            .thenAnswer((_) => Stream.value([testExpense]));
+
+        // Test data consistency across screens
+        await tester.pumpWidget(createTestApp(const GroupsScreen()));
+        await tester.pumpAndSettle();
+        expect(find.text('Test Group'), findsOneWidget);
+
+        await tester.pumpWidget(createTestApp(const MyExpensesScreen()));
+        await tester.pumpAndSettle();
+        expect(find.text('Test Expense'), findsOneWidget);
+
+        await tester.pumpWidget(createTestApp(GroupDetailScreen(group: testGroup)));
+        await tester.pumpAndSettle();
+        expect(find.text('Test Expense'), findsOneWidget);
+      });
+    });
+  });
+}
EOF
)